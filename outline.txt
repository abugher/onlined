x Main loop:
  x Check online status.
    - Option:  Active check.
      - Requires sending traffic.
      - Announces presence to that address.
      - Announces an identifying quirk to the LAN.
    x Option:  Passive check.
      - Watch for traffic not matching any routing rule, other than default gateway.  (...a method for above, I guess.)
        - Elegant.
        - Option:  Parse the routing rules.
          - No.
        - Option:  Ask the kernel.
          - This might require an iptables rule to log any traffic being
            routed through the default gateway.
          - Might need to exclude traffic directly TO the gateway.
      x Watch for traffic not to this subnet.
        - States:
          - Outbound present, inbound missing:
            - Offline.  Connections (presumably) failing.
          - Outbound present, inbound present:
            - Online.
          - Outbound absent, inbound present:
            - Online, although strangely quiet.
          - Outbound absent, inbound absent:
            - Unknown.
            - Could be offline.
            - Could just be quiet.
            - Maybe require a constant traffic generator, like NTP.
        - Assumes that "the LAN" consists of one subnet.
        - More than one subnet accessible by the same machine implies the machine is a router.  That's not my use case.
  x Get online.
    x Read interface spec names from ifupdown configuration.
    x Bring down all* interfaces.
      - *Except lo.
    x For each spec name:
      - If it is the name of an interface:  
          ifup $spec_name && return || ifdown [..]
    x For each spec name:
      - If it is the name of a wifi network in range:
          ifup "${wifi_interface}=${spec_name}" && return || return [...]
  x Sleep, I guess.

- Drop privileges where reasonable.
- Handle failures.
